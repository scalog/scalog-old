syntax = "proto3";

package messaging;

/*
gRPC for Order layer of Scalog
*/
service Order {
    rpc Report(stream ReportRequest) returns (stream ReportResponse) {}

    rpc Forward(stream ReportRequest) returns (stream ForwardResponse) {}

    rpc Register(RegisterRequest) returns (RegisterResponse) {}

    rpc Finalize(FinalizeRequest) returns (FinalizeResponse) {}
}

message ReportRequest {
    int32 shardID = 1;
    int32 replicaID = 2;
    repeated int32 tentativeCut = 3;
    // True only if the ordering layer wishes to propose a finalization of this particular shard
    bool finalized = 4;
}

message IntList {
    repeated int32 list = 1;
}

message ForwardResponse {
	map<int32, int32> startGlobalSequenceNums = 1; // Gsn to start counting off of
    map<int32, IntList> committedCuts = 2;
    int32 startGlobalSequenceNum = 3; //The next unused gsn
}

message ReportResponse {
    int32 startGlobalSequenceNum = 1;
    repeated int32 committedCuts = 2;
    // range [minLogNum, maxLogNum] includes all newly applied entries & config changes (inclusive)
    int32 minLogNum = 3;
    int32 maxLogNum = 4;
    // True only if the ordering layer is finalizing this data replica
    bool finalized = 5;
}

message RegisterRequest {
    int32 shardID = 1;
    int32 replicaID = 2;
}

message RegisterResponse {}

message FinalizeRequest {
    // Array of shards to finalize
    repeated int32 shardIDs = 1;
    // Finalize these shards after [finalizeAfterCuts] more cuts
    int32 finalizeAfterCuts = 2;
}

message FinalizeResponse {}

// Finalize needs to be sent from shards or from ordering? Client application that can manually finalize.
